\documentclass[11pt,twoside]{report}

\usepackage{standalone}
\input{../article-template.tex}

\title{Introducción simple a Python 3}
\author{Joseph Höhlen}
\date\today

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\usepackage{listings}
\lstset{inputencoding=latin1,
	extendedchars=true,
	language=Python,
	backgroundcolor=\color{gray!15},
	basicstyle=\small\ttfamily,
	breaklines=true,
	numbers=none,
	frame=leftline,
	tabsize=4,
	showstringspaces=false,
	commentstyle=\color{mygreen},
	keywordstyle=\color{blue},
	stringstyle=\color{mymauve},
}
\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {Ã}{{\~A}}1 {ã}{{\~a}}1 {Õ}{{\~O}}1 {õ}{{\~o}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
} % Para poder escribir código

\begin{document}
\maketitle

\chapter*{Introducción e instalación}
\section*{Requerimientos}
El presente artículo/reporte constituye una introducción rápida y sencilla a lo que en el momento es uno de los lenguajes de programación más importantes que hay: Python. Este no requiere de muchas capacidades, a lo que tengo entendido, con menos de 1GB de disco puedes trabajar en Windows 7+; el lenguaje per se es bastante liviano, de hecho, lo más ``pesado'' es que para este reporte utilizaremos el editor de PyCharm de Jet Brains, el cual pide un mínimo de 4GB de RAM (no es obligatorio, pero si recomendado).

Por otro lado, este artículo pretende ser ante para un público dedicado a las ciencias físico-matemáticas, por lo cual el léxico, terminología y explicaciones están adaptadas para ellos; aun que soy de la noción que verdaderamente cualquiera puede programar y debería ser asignatura obligatoria. Matemáticamente no hay mucho que saber de antemano, tal vez se recomienda familiarizarse con el plano cartesiano y las ideas básicas en física de velocidad, posición y aceleración.

Cabe decir que los ejemplos pueden considerarse ejercicios y deberían hacerse, he puesto mis propios intentos pero la idea es crear el tuyo; no existen dos razonamientos exactamente iguales y, por lo tanto, no hay una única respuesta definitiva a los problemas que he de presentar en este artículo.

\section*{Instalación}
Lo esencial es por supuesto el lenguaje, para ello vaya a la página oficial de Python \url{https://www.python.org/} y descargue la versión más reciente a través del instalador.
\begin{figure}
\centering
\includegraphics[width=.75\textwidth]{python-install.jpg}
\caption{}
\end{figure}

Luego a la de PyCharm \url{https://www.jetbrains.com/pycharm/download/} (la versión \textit{Community} es gratuita). Una vez completada la instalación, abra PyCharm y debería aparecer una ventana con varias opciones, seleccione \texttt{Configure > Settings}
\begin{figure}
\centering
\includegraphics[width=.75\textwidth]{pycharm-configure.jpg}
\caption{}
\end{figure}

En la esquina izquierda asegúrese de estar en \texttt{Project interpreter}, luego seleccione el símbolo de engranaje y presione \texttt{Add}
\begin{figure}
\centering
\includegraphics[width=.83\textwidth]{pycharm-interpreter.jpg}
\caption{}
\end{figure}\\
(\textbf{Nota:} en su pantalla no deberían haber caracteres en el \textit{rectángulo central}, en mi caso si pues ya tengo mi interpretador configurado.)

Tras ello aparecerá una nueva ventana, asegúrese de estar en \texttt{Virtualenv Environment} y que en \texttt{Base interpreter} aparezca Python con la versión descargada (en mi caso 3.7), si este campo aparece vacío, busque la carpeta en donde dejó el lenguaje instalado y seleccione el archivo \texttt{python.exe} y marque la opción de \texttt{Make available to all projects}.
\begin{figure}
\centering
\includegraphics[width=.83\textwidth]{pycharm-env.png}
\caption{}
\end{figure}

Finalmente presione \texttt{Ok}, \texttt{Apply} y \texttt{Ok} para terminar el proceso y para asegurarse de haberlo hecho bien, presione \texttt{Create new project} para crear un proyecto que llamaremos \texttt{Tutorial}. Expanda la sección de \texttt{Project interpreter: Python 3} para asegurarse de que nuestro interpretador este seleccionado como en la fotografía.
\begin{figure}
\centering
\includegraphics[width=.9\textwidth]{pycharm-project.jpg}
\caption{}
\end{figure}

Vaya a \texttt{File > New > Python file} y dele un nombre cualquiera y escriba \lstinline|print("Hola mundo")| haga click en \texttt{Run > Run} y seleccione su archivo. Abajo debería aparecer el texto \texttt{Hola mundo} como en la figura (el tamaño de fuente fue modificado para el artículo)
\begin{figure}
\centering
\includegraphics[width=.9\textwidth]{pycharm-test.png}
\caption{}
\end{figure}

Si usted ha obtenido la misma respuesta, felicidades, acaba de escribir su primer programa en Python.

\chapter{``Hola mundo''}
En la introducción ya mostramos, para comprobar que la instalación fue exitosa, el como escribir el típico ``Hola mundo'', sin embargo, antes de seguir escribiendo archivos vamos a ir a la parte de \texttt{Python console} y esperar a que nos aparezca algo así:
\begin{figure}
\centering
\includegraphics[width=\textwidth]{python-console.jpg}
\caption{}
\end{figure}

A esta parte le llamaremos la \textbf{consola}. Aquí ejecutaremos código cuyas respuestas serán inmediatas. Servirá para probar segmentos de código aun que no es recomendable escribir largas secuencias aquí pues no se guarda y es más complicado.

\section{Métodos numéricos}
Probemos pedirle a la consola que nos ayude con ciertas operaciones, para ello escriba las siguientes lineas (usted escribe lo que aparece en \lstinline|>>>|, las líneas sin aquello son las respuestas de la consola)
\begin{lstlisting}
>>> 4+2 # suma
6
>>> 4-2 # resta
2
>>> 4*2 # multiplicación
8
>>> 4/2 # división
2.0
>>> 4**2 # potencias
16
>>> 4%2 # reserva de la división
0
\end{lstlisting}
Nótese que Python no lee lo que aparece después del signo \#{}, esto se debe a que aquello señala un \textit{comentario} (código invisible, usualmente instructivo). También que todos los números aparecieron sin punto decimal excepto la división, ¿por qué ocurre? Esto se debe a que Python trabaja tres tipos de números
\begin{description}
\item[\tt Enteros] Se denotan sin punto decimal (\lstinline|int(...)|).
\item[\tt Racionales] Se denotan con punto decimal, también llamados \textit{float} (\lstinline|float(...)|).
\item[\tt Complejos] Se denotan como decimales sólo que con parte imaginaria cuya unidad utiliza la letra \texttt{j} (sí, \texttt{j} y no \texttt{i}). \lstinline|1+j| da error, pues siempre se debe escribir la cantidad imaginaria, incluso cuando es 1 (\lstinline|complex(..., ...)|).
\end{description}
Python al realizar divisiones, multiplicaciones por racionales o potencias no-naturales convierte el entero en racional para evitar cálculos erróneos. Esto no se daba en Python 2.7 con las divisiones y era bien sabido que al escribir \lstinline|5/2| obtenías \lstinline|2|?! Esto se debe a que la consola sólo toma la parte entera del resultado real que es 2.5.

Al final de la definición he puesto unas funciones de Python que convierten uno en el otro, verá que \lstinline|int(0.9999999)=0|. El doble argumento de los complejos sirve para que el primero indique parte \textit{real} y el segundo parte \textit{imaginaria}.

Pero, como en todo lenguaje de programación, en Python querremos definir variables (objetos cuyo valor podemos cambiar), para ello simplemente escribimos un nombre (solamente alfanumérico y que comience con una letra) seguido de igual a algo, por ejemplo
\begin{lstlisting}
>>> x = 2
>>> x
2
\end{lstlisting}
Quiero poner la atención sobre el siguiente fenómeno:
\begin{lstlisting}
>>> x = 2
>>> y = 2
>>> x = 1
>>> y
2
\end{lstlisting}
Esto se debe a que cuando le decimos a Python \lstinline|y = x|, realmente lo que lee es ``$y$ igual al valor de $x$ en ese instante''. Por ello, la siguiente linea de código
\begin{lstlisting}
>>> x = 2
>>> x = x+1
>>> x
3
\end{lstlisting}
Tiene sentido, pues lo que Python lee en la segunda línea es que ``$x$ sea igual al valor anterior de $x$ + 1''. Para ello utilizamos las siguientes abreviaciones de \lstinline|x += 1| es lo mismo que \lstinline|x = x+1| y análogo con \lstinline|-=|, \lstinline|*=|, \lstinline|/=|, \lstinline|**=| y 
\lstinline|%=|.

Otro método disponible de Python es el de obtener los valores absolutos, por ejemplo
\begin{lstlisting}
>>> abs(-1)
1
>>> abs(3+4j) # 3^2+4^2=5^2
5.0
\end{lstlisting}
Además de ello, los complejos poseen tres métodos únicos para ellos, sea $z$ un complejo, entonces \lstinline|z.real()| nos da su parte real, \lstinline|z.imag()| su parte imaginaria y \lstinline|z.conjugate()| es su conjugado.

Una recomendación es que para ahorrar líneas de código puedes definir varias variables en una sola, separandolas por comas
\begin{lstlisting}
x, y, z = 2, -5.0, 1+2j
\end{lstlisting}

\section{Paquetes y cadenas}
Un \textbf{paquete} es un archivo de Python que incrementa sus funciones comunes y corrientes, usualmente a través de nuevas constantes, funciones e inclusive métodos. Hay tres formas de implementar un paquete, tomaremos de ejemplo el paquete \lstinline|math| que viene incluido con Python
\begin{lstlisting}
import math
import math as ... # aquí va un nombre que elijas
from math import ... # aquí van los objetos que deseas importar
\end{lstlisting}
El paquete \lstinline|math| viene con la función \lstinline|sin()| por dar un ejemplo. Supongamos que escribimos lo primero, para llamar a dicha función escribiríamos \lstinline|math.sin()|. Si elegimos la segunda y le pones de nombre \lstinline|mt| tendríamos que llamarla como \lstinline|mt.sin()|. En la última escribiríamos \lstinline|from math import sin| para importar \textbf{únicamente} la función \lstinline|sin| y se escribe tal cual. Si queremos importarlo todo escribimos un asterisco.

Sigamos con la narrativa de que deseamos importar el paquete \lstinline|math| y queremos ver su lista de objetos. Escribimos \lstinline|dir(math)|, si le cambiamos el nombre con el \lstinline|as| ponemos ese nombre.

Otro tipo de variables son las \textbf{cadenas}, es decir, partes de texto, estás se caracterizan por las comillas simples \lstinline|'...'| o dobles alrededor \lstinline|"..."|. Usando el comando \lstinline|print(...)| puedes indicarle a la consola que imprima cadenas u otros objetos; al hacerlo las comillas externas desaparecerán.
\begin{lstlisting}
>>> cadena = '¡Hola mundo!'
>>> print(cadena)
¡Hola mundo!
\end{lstlisting}
Puedes escribir un salto de línea con \lstinline|\n|.

Puedes imprimir varios objetos en una sola línea separándole por comas (Python automáticamente añade un espacio entre dichos objetos). Además, dos cadenas se pueden ``sumar'' en el sentido de que se unen
\begin{lstlisting}
>>> a, b = 'Hola', 'Adiós'
>>> a+b
'HolaAdiós'
>>> print(a, b)
Hola Adiós
\end{lstlisting}
Asimismo, podemos ``multiplicar'' una cadena por un natural no nulo para ver que esta se repite las veces pedidas
\begin{lstlisting}
>>> cadena = 'Hola'
>>> cadena*3
'HolaHolaHola'
\end{lstlisting}
Podemos convertir ciertos objetos en cadenas con el comando \lstinline|str(...)|.

Algo que usualmente se desea es interactuar con el usuario, para ello utilizaremos el comando \lstinline|input('Algún texto...')| y para guardarlo haremos que una variable sea igual a dicho \texttt{input}. Por ejemplo, este código acontinuación pregunta por nombre y da un saludo personalizado
\begin{lstlisting}
nombre = input('¿Cuál es tu nombre? ') # i.e. Joe
print('Hola,', nombre) # resp. 'Hola, Joe'
\end{lstlisting}
Otros métodos más avanzados con Python son \lstinline|.replace(a, b, n*)| (reemplaza la cadena $a$ por $b$ una cantidad $n$ de veces, si el campo de la cantidad está vacío lo hace la cantidad de veces que se repite $a$ en la cadena; si $a$ no aparece entonces no se ve afectada), \lstinline|.capitalize()| (la primera letra se pone en mayúsculas), \lstinline|.title()| (la primera letra de cada palabra se pone en mayúsculas), \lstinline|.upper()| (todo en mayúsculas) y \lstinline|.lower()| (todo en minúsculas).
\begin{lstlisting}
>>> txt = 'Hola, mundo. ¿Cómo estas, mundo?'
>>> txt.lower()
'hola, mundo. ¿cómo estas, mundo?'
>>> txt.title()
'Hola, Mundo. ¿Cómo Estas, Mundo?'
>>> txt.upper()
'HOLA, MUNDO. ¿CÓMO ESTAS, MUNDO?'
>>> txt.replace('mundo', 'Joe')
'Hola, Joe. ¿Cómo estas, Joe?'
>>> txt.replace('mundo', 'Joe', 1)
'Hola, Joe. ¿Cómo estas, mundo?'
\end{lstlisting}
Además, existen las funciones \lstinline|eval()|, que evalúan la cadena como si fuera una única línea de código, en particular para definir variables; mientras que \lstinline|exec()| ejecuta el código. Por ejemplo:
\begin{lstlisting}
>>> eval('1+2')
3
>>> exec('print("Hola mundo")\nprint("¿Cómo estás?")')
Hola mundo
¿Cómo estás?
\end{lstlisting}

\section{Colecciones o \textit{arrays}}
Además de las cadenas y los números, hay otro tipo de objetos en Python: las colecciones o, en ingles, \textit{arrays}; son aquellas que pueden guardar más de un objeto a la vez. Veremos dos de ellas:
\begin{description}
\item[\tt Listas] Se delimitan por corchetes y sus elementos se separan por comas. Pueden ser de cualquier tipo (inclusive otras listas, i.e \lstinline|[1, 'Uno', [1]|).
\item[\tt Tuplas] Son similares a las listas, con diferencia de que no permite modificaciones como añadir, remover o modificar elementos individuales. Se delimitan con paréntesis (i.e. \lstinline|(1, 2, 'Tres')|).
\end{description}
Puedes convertir un array o una cadena en una lista con \lstinline|list(...)| o en una tupla \lstinline|tuple(...)| (\lstinline|list(1)| da error).

Lo interesante de las listas es que a pesar de ser dos tipos distintos de objetos en Python, los métodos se pueden aplicar a los dos por igual:
\begin{longtable}{lp{8cm}}
\lstinline|len(lista)| & Otorga un entero equivalente a la longitud de la colección (funciona con cadenas).\\
\lstinline|min(lista), max(lista)| & Nos da el mínimo y máximo respectivamente de la colección\footnote{Otorga error si posee elementos no-numéricos o complejos.}.\\
\lstinline|.index(a)| & Otorga el entero correspondiente al índice del objeto $a$ (da error si $a$ no está en la colección y considere que el primer elemento se le asigna índice ``0'').\\
\lstinline|.count(a)| & Otorga la cantidad de veces que aparece $a$ en el array.\\
\lstinline|r+s| & Otorga la unión de dos arrays del mismo tipo.\\
\lstinline|r*n| & Otorga un array repetida $n$ veces.
\end{longtable}
Si se posee una lista \lstinline|lista| podemos utilizar el método \lstinline|lista.remove(a)| para quitarle el elemento $a$ (da error si $a$ no pertenece a la lista) y podemos utilizar \lstinline|lista.append(a)| para añadir dicho elemento (incluso si este ya estaba incluido).

Además, las listas y tuplas son \textit{ordenadas}, es decir, admiten métodos relacionados a índices. Un \textit{índice} es la ``posición'' de un elemento en un array. \lstinline|array[n]| da el objeto en la posición $n+1$ (pues el primer objeto posee índice ``0''). \lstinline|array[i:f]| es un array que contiene los elementos desde la posición $i$ hasta $f-1$. \lstinline|array[:f]| es igual que \lstinline|array[0:f]| y \lstinline|array[i:]| es igual a \lstinline|array[i:n]| si el array posee $n$ elementos. Todo se ve mejor en la imagen:
\begin{figure}
\centering
\includegraphics[scale=1]{python-slicing.png}
\caption{}
\end{figure}

Vemos que estos métodos de \textit{cortar} y de los índices funcionan también con cadenas.

Una cadena puede separarse y convertirse en una lista con \lstinline|cadena.split(corte)| donde \lstinline|corte| es una sección (obligatoriamente otra cadena) que la va a separar, si se deja en blanco se toma como un espacio:
\begin{lstlisting}
>>> cadena = 'Esta es una cadena'
>>> cadena.split()
['Esta', 'es', 'una', 'cadena']
>>> cadena.split('es')
['Esta ', ' una cadena']
\end{lstlisting}
Igualmente podemos tomar un array de cadenas y convertirlo en tal usando \lstinline|corte.join(array)|:
\begin{lstlisting}
>>> array = ['Este', 'es', 'un', 'array']
>>> ' '.join(array)
'Este es un array'
\end{lstlisting}

\subsection{Conjuntos}
Similares a las listas, los \textit{conjuntos} se delimitan por llaves y también poseen los atributos de \lstinline|len(...)|, \lstinline|min(...)| y \lstinline|max(...)|. Sus elementos no pueden ser ni listas ni diccionarios. Además, el conjunto se considera \textit{desordenado}, lo que quiere decir que no acepta métodos relacionados a los índices.

Para añadir un elemento a un conjunto utilizamos \lstinline|conjunto.add(elemento)|, para removerlo podemos utilizar \lstinline|conjunto.discard(a)| o \lstinline|conjunto.remove(a)| (si el elemento $a$ no estaba en el conjunto, \lstinline|remove()| dará error). Otros métodos son:
\begin{lstlisting}
>>> a, b = {1, 2, 3}, {3, 4, 5}
>>> a.union(b) # elementos que estén en a o en b
{1, 2, 3, 4, 5}
>>> a.intersection(b) # elementos que estén en a y en b
{3}
>>> a.difference(b) # elementos de a que no estén en b
{1, 2}
>>> a.symmetric_difference(b) # elementos de la unión entre a y b que no estén en ambos simultáneamente
{1, 2, 4, 5}
\end{lstlisting}
Puedes convertir arrays y cadenas en conjuntos con \lstinline|set(...)|.

\subsection{Diccionarios}
Se delimitan por llaves y sus elementos deben ser seguidos de dos puntos a los que prosigue una definición. Las definiciones pueden ser cualquier tipo de objetos, sin embargo, los elementos no pueden ser ni listas, ni conjuntos, ni diccionarios (i.e. \lstinline|{1: 'Uno'}|). Puedes convertir un diccionario en una lista, con lo cuál obtienes una solamente con los términos sin sus definiciones, por ejemplo
\begin{lstlisting}
>>> diccionario = {1: 'Uno', 2: 'Dos', 3: 'Tres'}
>>> list(diccionario)
[1, 2, 3]
\end{lstlisting}
Lo mismo ocurre con \lstinline|tuple()| y \lstinline|set()|.

La particularidad de los diccionarios es que si bien no utilizan índices, pues son desordenados, si puedes utilizar \lstinline|diccionario[término]| para obtener su valor; igualmente puedes utilizar el mismo para añadir más términos por ejemplo
\begin{lstlisting}
>>> diccionario = {'nombre': 'Joe', 'apellido': 'Bananas'}
>>> diccionario['nombre']
'Joe'
>>> diccionario['edad'] = 20
>>> diccionario
{'nombre': 'Joe', 'apellido': 'Bananas', 'edad': 20}
\end{lstlisting}
Los métodos de \lstinline|len()|, \lstinline|min()| y \lstinline|max()| también son aceptados. Además de los métodos especiales de \lstinline|.keys()| para obtener un array de términos y \lstinline|.values()| de los valores; incluso \lstinline|.items()| para obtener un array de duplas de cada término con su respectivo valor:
\begin{lstlisting}
>>> diccionario = {'nombre': 'Joe', 'apellido': 'Bananas', 'edad': 20}
>>> diccionario.keys()
dict_keys(['nombre', 'apellido', 'edad'])
>>> diccionario.values()
dict_values(['Joe', 'Bananas', 20])
>>> diccionario.items()
dict_items([('nombre', 'Joe'), ('apellido', 'Bananas'), ('edad', 20)])
\end{lstlisting}
Para eliminar un término y su valor se utiliza \lstinline|diccionario.pop(término)|. Finalmente utilizando \lstinline|.clear()| pueden borrar todos los elementos de cualquier array.

\section{Booleans}
En casi todos los lenguajes de programación hay un tipo de objetos llamados \textit{booleans} cuyos únicos posibles valores es verdadero o falso. Su uso es el de servir en condicionales y bucles. En Python no es la excepción y se denotan como \lstinline|True| y \lstinline|False| respectivamente. En esta sección veremos unos métodos que entregan booleans.

Primero, al igual que con los números y las cadenas, el comando \lstinline|bool(...)| cambia un valor a una boolean. Entre los números, todo valor distinto de 0 nos da \lstinline|True| y el cero da \lstinline|False|. Entre las listas y cadenas, toda aquella que sea no vacía da \lstinline|True|. Puedes negar o revertir el valor de una boolean escribiendo \lstinline|not| antes.
\begin{lstlisting}
>>> not bool(0)
True
\end{lstlisting}
Dadas dos variables numéricas $x$, $y$ podemos aplicar los siguientes operadores:
\begin{figure}
\centering
\begin{tabular}{cc|cc}\hline
Operador & Significado & Operador & Significado\\ \hline\hline
\lstinline|==| & Igual que & \lstinline|!=| & No es igual que\\
\lstinline|<| & Menor que & \lstinline|<=| & Menor o igual que\\
\lstinline|>| & Mayor que & \lstinline|>=| & Mayor o igual que\\ \hline
\end{tabular}
\end{figure}
Veamos que no podemos aplicar los operadores \lstinline|<|, \lstinline|>|, \lstinline|<=| y \lstinline|>=| entre complejos y elementos no numéricos.

Otro operador es el \lstinline|is| que es aún más estricto, pues \lstinline|==| compara si dos números (u otros objetos) poseen el mismo valor, sin embargo, el \lstinline|is| califica que sean completamente iguales, inclusive en tipo:
\begin{lstlisting}
>>> 1 == 1.0
True
>>> 1 is 1.0
False
\end{lstlisting}
Dos listas o tuplas se consideran ``iguales'' si sus elementos \textbf{correspondientes al orden} poseen el mismo valor, en cambio, dos conjuntos se consideran iguales si poseen los mismos valores en cualquier orden:
\begin{lstlisting}
>>> [1, 2] == [2, 1]
False
>>> {1, 2} == {2, 1}
True
\end{lstlisting}
Un operador propio de las listas, diccionarios y cadenas es el \lstinline|in|. Si una cadena está contenida en otra o un elemento en una lista/diccionario, eso lo detecta este operador:
\begin{lstlisting}
>>> 1.0 in [1, 2]
True
>>> '1' in {'1': 'uno'}
True
>>> 'mundo' in 'Hola mundo'
True
\end{lstlisting}
También puedes ver si una cadena es alfanumérica con \lstinline|cadena.isalnum()| o simplemente alfabética \lstinline|cadena.isalpha()|.

\chapter{Condicionales y bucles}
\section{\texttt{if-elif-else}}
Antes de seguir debemos indicar que cuando dijimos que las variables podían tener cualquier nombre alfanumérico, mentimos. Pues, como todo lenguaje, Python posee una serie de palabras reservadas cuyo uso como variables da error:
\begin{center}
\lstinline|and|, \lstinline|as|, \lstinline|assert|, \lstinline|break|, \lstinline|class|, \lstinline|continue|, \lstinline|def|, \lstinline|del|, \lstinline|elif|, \lstinline|else|, \lstinline|except|, \lstinline|finally|, \lstinline|for|, \lstinline|from|, \lstinline|global|, \lstinline|if|, \lstinline|import|, \lstinline|in|, \lstinline|is|, \lstinline|lambda|, \lstinline|not|, \lstinline|nonlocal|, \lstinline|or|, \lstinline|pass|, \lstinline|print|, \lstinline|raise|, \lstinline|return|, \lstinline|try|, \lstinline|while|, \lstinline|with|, \lstinline|yield|
\end{center}
En la última sección del capítulo también supimos de la existencia de los booleans, sin embargo, no hemos visto sus usos, los que probablemente sean mejor empleados por los condicionales.

Utilizando el comando \lstinline|if condición| podemos escribir código que sólo funcione si una condición se cumple:
\begin{lstlisting}
frutas = ['manzanas', 'bananas', 'naranjas']
if 'manzanas' in frutas:
    print('Tienes manzanas') # produce 'Tienes manzanas'
\end{lstlisting}
Puedes probar eliminando dicho elemento de la lista. Podemos ver que las condiciones en realidad son booleans que funcionan cuando es verdadero y no lo hacen cuando es falso, es decir, el programa
\begin{lstlisting}
if False:
	print('Esto no se imprime')
if True:
	print('Esto sí')
\end{lstlisting}
produce ``Esto sí'' siempre. Cabe destacar que a diferencia de otros lenguajes basados-en-C o Pascal, por ejemplificar, Python no requiere de una secuencia de inicio como llaves o un \lstinline|begin-end|, en cambio, todo lo que respeta el tabulador se considera \textit{parte} o consecuencia del \lstinline|if|.

Volvámonos un poco más ambiciosos, ahora escribiremos un programa que imprima si somos o no, mayores de edad. Podemos ver que requerimos de dos condicionales, sin embargo, una es la opuesta de la otra; cuando ocurre esto utilizamos el \lstinline|else|, como sigue
\begin{lstlisting}
edad = 17
if edad >= 18:
    print('Eres mayor de edad')
else:
    print('Eres menor')
\end{lstlisting}
El código debe interpretarse como que primero ve si edad es mayor o igual a 18 y luego, si no lo es, va a la otra condicional. Es imprescindible que el usario sepa que si se cumple el \lstinline|if|, no leerá el código de \lstinline|else|. Igualmente, existe el \lstinline|elif| que es una mezcla entre \lstinline|else| e \lstinline|if|, que, de no activarse la primera condición va a la siguiente y así sucesivamente, por ejemplo
\begin{lstlisting}
edad = 22
if edad >= 60:
    print('Eres de tercera edad')
elif edad >= 40:
    print('Aún eres joven')
elif edad >= 18:
    print('Eres apenas adulto')
else:
    print('Eres menor')
\end{lstlisting}
Como la primera y segunda condición no son ciertas las pasa y lee la tercera, produciendo ``Eres apenas mayor'' y no lee las siguientes condiciones.

Para finalizar, hay veces donde queremos tener múltiples condiciones, para ello podemos utilizar las palabras \lstinline|and| para especificar que se cumplan varias condiciones a la vez y el \lstinline|or| para ver que se cumpla al menos una, por ejemplo:
\begin{lstlisting}
edad, frutas = 22, ['naranjas']
if edad >= 60:
    print('Eres de tercera edad')
elif edad >= 18 or len(frutas) > 0:
    print('Eres adulto o tienes frutas')
else:
    print('Eres menor y no tienes ninguna fruta')
\end{lstlisting}

\section{Bucles}
\subsection{\texttt{for}}
En Python también solemos utilizar \textit{bucles}, es decir, acciones que se repiten varias veces; para ello tenemos dos clases de herramientas, la primera es el \lstinline|for|.

El \lstinline|for| funciona con elementos de una array. Para ellos veremos primero la función \lstinline|range(...)|. \lstinline|range(n)| genera un array ascendente de enteros desde 0 hasta $n-1$, \lstinline|range(a,b)| genera un array de enteros desde $a$ hasta $b-1$ y \lstinline|range(a,b,s)| hace lo mismo pero avanzando con una separación de $s$ entre sus elementos, por ejemplo
\begin{lstlisting}
>>> list(range(6))
[0, 1, 2, 3, 4, 5]
>>> list(range(1,6))
[1, 2, 3, 4, 5]
>>> list(range(1,6,2))
[1, 3, 5]
\end{lstlisting}
En la práctica sólo utilizaremos el primero o el segundo. El bucle \lstinline|for| funciona para los elementos de un array, escribiendo \lstinline|elemento in array|, para aclararlo mejor:
\begin{lstlisting}
for i in range(5)
	print(i)
# 0
# 1
# 2
# 3
# 4
\end{lstlisting}
Aquí $i$ es realmente un nombre cualquiera para un elemento del array. En este sentido, las cadenas se comportan como colecciones de caracteres, por lo que
\begin{lstlisting}
for caracter in 'Hola':
    print(caracter)
# H
# o
# l
# a
\end{lstlisting}
Además, podemos expandir las funciones del \lstinline|for| utilizando el comando \lstinline|break|. Este último es una única linea que lo que hace es terminar de antemano un bucle, por ejemplo
\begin{lstlisting}
for i in range(10):
	if i == 5:
		break # al llegar al 5 sale del bucle
	print(i)
# 0
# 1
# 2
# 3
# 4
\end{lstlisting}
Por otro lado, si no se quiere salir completamente del bucle, pero si salir de una iteración y continuar con la siguiente se utiliza el \lstinline|continue|, por ejemplo
\begin{lstlisting}
for i in range(5):
	if i == 3:
		continue # al llegar al 3 se sale de la iteración o vuelta y continua con la siguiente
	print(i)
# 0
# 1
# 2
# 4
\end{lstlisting}

\subsubsection*{Casos}
Una leve desventaja de Python es que al contrario de otros lenguajes basados-en-C, no posee una herramienta de casos. Aquella es aquel tal que dado algún valor de algo entre otros múltiples valores, da un resultado. Si bien, no está en el programa per se, un sustituto es utilizar una mezcla entre bucle \lstinline|for| y condiciones \lstinline|if| gracias a un \textbf{diccionario}.

Por ejemplo, supongamos que podemos obtener el mes a través de una variable del mismo nombre, pero que sólo nos da un número entre 1 y 12, luego, para convertir aquello en un nombre podemos utilizar el código:
\begin{lstlisting}
mes, mesNombre = 5, ''
diccionario = {1: 'Enero', 2: 'Febrero', 3: 'Marzo', 4: 'Abril', 5: 'Mayo', 6: 'Junio', 7: 'Julio', 8: 'Agosto', 9: 'Septiembre', 10: 'Octubre', 11: 'Noviembre', 12: 'Diciembre'}
for número in diccionario:
    if mes == número:
        mesNombre = diccionario[número]
print(mesNombre)
# Mayo
\end{lstlisting}
\textbf{Nota:} como en este caso, los meses están enumerados del 1 al 12, otro método más efectivo sería escribir una lista con los meses ordenados, luego utilizar los métodos de índice con índice $i-1$ (pues Enero tendría índice ``0'') y un elemento \lstinline|range(12)|.

\subsection{\texttt{while}}
Mientras que el \lstinline|for| sirve para realizar operaciones con arrays, el bucle \lstinline|while| sirve para realizar operaciones mientras una condición sea verdadera:
\begin{lstlisting}
i = 0
while i < 5:
    print(i)
    i += 1
# 0
# 1
# 2
# 3
# 4
\end{lstlisting}
Esto es particularmente útil para juegos o preguntas para el usuario como por ejemplo
\begin{lstlisting}
número = 0
while not(0 < número and número < 10):
    número = int(input('Diga un número estrictamente entre 0 y 10: '))
print('Elegiste el', número)
# Diga un número estrictamente entre 0 y 10: 10
# Diga un número estrictamente entre 0 y 10: 0
# Diga un número estrictamente entre 0 y 10: 5
# Elegiste el 5
\end{lstlisting}
con el \lstinline|while| también se aplican los métodos de \lstinline|break| y \lstinline|continue| con las mismas funciones.

\section{\texttt{try-except}}
La verdad hay un problema con el último programa que utilizamos de ejemplo y es que el método \lstinline|int()| da error si escribimos una cadena que posea caracteres no-numéricos (excepto un punto como divisor decimal o una ``e'' de exponente de 10). Aquí ni las condicionales \lstinline|if| sirven, pues no pueden escapar al error. Para ello existe la secuencia de \lstinline|try|-\lstinline|except|. Todo lo que está dentro de \lstinline|try:| es aquello que se \textit{intenta} ejecutar, si este código da error pasa a \lstinline|except:|, aplicado en el ejemplo anterior queda:
\begin{lstlisting}
número = 0
while not(0 < número and número < 10):
    try:
        número = int(input('Diga un número estrictamente entre 0 y 10: '))
    except:
        pass
print('Elegiste el', número)
# Diga un número estrictamente entre 0 y 10: a
# Diga un número estrictamente entre 0 y 10: 1
# Elegiste el 1
\end{lstlisting}
Aquí hay otro comando extraño que es el \lstinline|pass|. Esencialmente esto se escribe pues la secuencia \lstinline|try| debe ser procedida por \lstinline|except| (de lo contrario da error), y para no dejar este campo vacío se escribe dicha palabra (puede decirse que está allí para \textit{rellenar}).

Además de ello, puedes escribir un campo \lstinline|finally:| cuyo código se ejecuta independiente del \lstinline|try|-\lstinline|except|, por ejemplo
\begin{lstlisting}
try:
	number = int('Hola')
	print(number)
except:
	print('No se pudo convertir')
finally:
	print('Adiós')
# No se pudo convertir
# Adiós
\end{lstlisting}

\section{Ejemplos}
\subsection{Ahorcado}
De antemano sepa que existe una función \lstinline|randint(a,b)| que nos da un entero aleatorio entre e incluyendo el $a$ y el $b$; función perteneciente al paquete \lstinline|random|, que se incluiría con
\begin{lstlisting}
from random import randint
\end{lstlisting}
Sabiendo esto y dado una lista de palabras como
\begin{center}
hormiga, babuino, tejon, murcielago, oso, castor, camello, gato, almeja, cobra, pantera, coyote, cuervo, ciervo, perro, burro, pato, aguila, huron, zorro, rana, cabra, ganso, halcon, leon, lagarto, llama, topo, mono, alce, raton, mula, salamandra, nutria, buho, panda, loro, paloma, piton, conejo, carnero, rata, cuervo, rinoceronte, salmon, foca, tiburon, oveja, mofeta, perezoso, serpiente, araña, cigüeña, cisne, tigre, sapo, trucha, pavo, tortuga, comadreja, ballena, lobo, wombat, cebra
\end{center}
se pide generar un juego de ahorcado que pregunte por letras y dado una cantidad de intentos nos permita ganar o perder.
\textbf{Recomendaciones:} Considere que tanto el intento como la palabra son listas, únalas al imprimirlas, pero trátelas como tal. Así, intercambiar letras equivale a elementos.\\
{\sc Respuesta:}
\begin{lstlisting}[numbers=left]
from random import randint
palabras = 'hormiga, babuino, tejon, murcielago, oso, castor, camello, gato, almeja, cobra, pantera, coyote, cuervo, ciervo, perro, burro, pato, aguila, huron, zorro, rana, cabra, ganso, halcon, leon, lagarto, llama, topo, mono, alce, raton, mula, salamandra, nutria, buho, panda, loro, paloma, piton, conejo, carnero, rata, cuervo, rinoceronte, salmon, foca, tiburon, oveja, mofeta, perezoso, serpiente, araña, cigüeña, cisne, tigre, sapo, trucha, pavo, tortuga, comadreja, ballena, lobo, wombat, cebra'.split(', ')

jugar, puntaje = True, 0
while jugar:
    palabra = palabras[randint(0, len(palabras))] # obtener palabra de la lista
    nuevaPalabra = list(palabra) # palabra como lista de sus letras
    adivinado = ['_']*len(nuevaPalabra) # espacios adivinados
    intentos = 0
    while intentos < 5:
        char = ''
        while not(char.isalpha() and len(char) == 1): # detecta que sea alfabético y una sola letra
            char = input('Diga una letra: ').lower()
        if not char in nuevaPalabra:
            intentos += 1
        else:
            while char in nuevaPalabra:
                n = nuevaPalabra.index(char)
                nuevaPalabra[n], adivinado[n] = '', char # borrar la letra de la lista y añadirlo a las letras adivinidas
        print(' '.join(adivinado), '[intentos restantes:', str(5-intentos)+']')
        if not '_' in adivinado:
            break # si no faltan caracteres salir del bucle
    if not '_' in adivinado:
        print('Felicidades, has ganado')
        puntaje += 1
    else:
        print('Has perdido, la palabra era', palabra)
    resp = ''
    while not(resp == 's' or resp == 'n'): # detectar que la respuesta sea 's' o 'n'
        resp = input('¿Jugar de nuevo (s/n)? ').lower()
        if resp == 'n':
            jugar = False
print('Tu puntaje fue de', puntaje)
\end{lstlisting}

\subsection{Panecillos}
``Panecillos'' es un juego en el cual dado un número determinado de intentos, el usuario debe adivinar un número de 3 cifras. Para ello posee tres palabras de ayuda:
\begin{center}
\begin{longtable}{lp{8cm}}
Panecillos & Ninguno de tus números está en el resultado\\
Pico & Una cifra es correcta pero en la posición incorrecta\\
Fermi & Una cifra es correcta en el lugar correcto.
\end{longtable}
\end{center}
\textbf{Recomendaciones:} Considere que tanto el número ingresado como el número secreto pueden ser listas y gracias a ellos analizar las reglas de los índices, mientras que también podemos considerarlos conjuntos para ver cuantos elementos poseen en común (intersección de conjuntos).\\
{\sc Respuesta:}
\begin{lstlisting}[numbers=left]
from random import randint

jugar, puntaje, max = True, 0, 7
while jugar:
    intentos = 0
    número = list(str(randint(100, 999))) # convierte el número en una lista
    while intentos < max:
        suposicion = '0'
        while len(suposicion) != 3:
            suposicion = input('De una suposición: ')
            try:
                suposicion = int(suposicion)
            except:
                suposicion = 0
            finally:
                suposicion = str(suposicion)
        suposicion = list(suposicion)
        if int(''.join(suposicion)) == int(''.join(número)): # ¿son iguales?
            break
        mensage = ''
        inter = set(suposicion).intersection(set(número))
        if not inter: # no comparten elementos en común
            mensage = 'Panecillos '
        else:
            for elem in inter:
                if any(suposicion[i] == número[i] == elem for i in [0, 1, 2]):
                    mensage += 'Fermi '
                if any(suposicion[i] == número[j] == elem and i != j for i in range(3) for j in range(3)):
                    mensage += 'Pico '
        intentos += 1
        print(mensage + '[intentos restantes: ' + str(max-intentos) + ']')
    if int(''.join(suposicion)) == int(''.join(número)):
        print('Ganaste')
        puntaje += 1
    else:
        print('Perdiste, tu número era', ''.join(número))
    resp = ''
    while not(resp == 's' or resp == 'n'):
        resp = input('¿Jugar de nuevo? (s/n) ')
    if resp == 'n':
        jugar = False
\end{lstlisting}

\chapter{Funciones y clases}
\section{Funciones}
Usualmente en Python --y cualquier lenguaje de programación por este contexto-- hay una o varias líneas de código que solemos repetir, por lo cual, sería útil tener una forma de sintetizar dicho código y la hay. Para definir una función comenzamos por \lstinline|def nombreFunción(argumento1, argumento2, ...):| como, por ejemplo:
\begin{lstlisting}
def función(x):
	print('Mi número es', x)
función(2)
# Mi número es 2
\end{lstlisting}
Pero imprimir los cálculos no bastan. Supongamos que queremos hacer una función que duplique el valor de la variable, no queremos que lo imprima, sino que lo podamos guardar en una variable (como con \lstinline|int()| que no imprime pero que regresa un valor), para ello utilizamos la palabra reservada \lstinline|return|:
\begin{lstlisting}
def duplicar(x):
	return x*2
doble = duplicar(2)
print(doble)
# 4
\end{lstlisting}
Un método bastante común de definir las funciones para números enteros es a través de la \textit{recursión}; esto quiero decir que defines un valor inicial y $f(n)=f(f(n-1))$, por ejemplo, para conseguir la función
$$S(n)=\sum_{i=0}^n i=1+2+\cdots+n,$$
podemos utilizar el siguiente código:
\begin{lstlisting}
def suma(n):
	if n == 0:
		return 0
	else:
		return n + suma(n-1)

for i in [1,2,3]:
	print(suma(i))
# 1
# 3
# 6
\end{lstlisting}
Sin embargo, algo posible, es que en estas dos funciones el argumento sea un número negativo o uno que posea valor no-entero, por lo cuál podríamos querer que este levante un error al ser ejecutado, para ello utilizamos \lstinline|raise| seguido del error\footnote{Puedes revisar los tipos de errores en \url{https://www.tutorialsteacher.com/python/error-types-in-python}.}, como sigue:
\begin{lstlisting}
def isInt(n):
	if not(type(n) is int or type(n) is float):
		raise TypeError('Sólo tipos de números reales se aceptan')
	elif n != int(n) or n < 0:
		raise ValueError('Sólo valores naturales se aceptan')
def suma(n):
	isInt(n)
	if n == 0:
		return 0
	else:
		return n + suma(n-1)
\end{lstlisting}
Si al final del código escribimos algo como \lstinline|suma('hola')| el programa dirá que hay un error  pues tu valor no es numérico, lo mismo si escribimos \lstinline|suma(2.1)|.

El gran problema de las funciones es que su definición suele ser larga, pero si la función es corta (exactamente una línea), podemos utilizar la palabra \lstinline|lambda args : ...| para definirlo, por ejemplo:
\begin{lstlisting}
>>> f = lambda x : x**2
>>> f(3)
9
>>> g = lambda : print('Hola mundo')
>>> g()
Hola mundo
\end{lstlisting}

\subsection{Variables locales}
Las funciones son interesantes con respecto al control de variables. Una variable externa puede ser utilizada dentro de una función, sin embargo, al ser modificada se convierte en \textit{una variable local} (cantidad interna de la función). Por ejemplo
\begin{lstlisting}
factor = 5
def f(x):
    return x*factor
def g(x):
    factor = 3
    return x*factor

print(f(5), g(5))
print(factor)
# 25 15
# 5
\end{lstlisting}
Aquí, a pesar de que le dijimos a \texttt{factor} que cambiara su valor a 3, lo que Python interpretó es que creáramos una variable local de nombre \texttt{factor} y valor 3. Si lo que deseamos es cambiar la variable globalmente utilizamos la palabra \lstinline|global|, por ejemplo:
\begin{lstlisting}
factor = 5
def f(x):
    global factor
    factor = 3
    return factor

print(f())
# 3 (ahora sí lo cambió)
\end{lstlisting}
Por otro lado, supongamos que tenemos una función $f(x)$ y definimos una variable \lstinline|factor| dentro de ella; supongamos también que tenemos otra función $g(x)$ dentro de la definición de $f(x)$, para poder modificar dicha variable, no utilizamos \lstinline|global| sino \lstinline|nonlocal|, por ejemplo:
\begin{lstlisting}
def f():
    factor = 5
    def g():
        nonlocal factor
        factor = 3
    g()
    return factor

print(f())
# 3 (borre la línea de nonlocal factor para ver que da 5)
\end{lstlisting}

\section{Clases}
Para finalizar con el curso de Python, veremos los objetos llamados \textit{clases}. Una clase es un tipo de objeto que puede almacenar información propia; se definen con la secuencia \lstinline|class NombreDeLaClase:| y con ello definimos ciertas variables internas, por ejemplo:
\begin{lstlisting}
class Número:
	valor = 5
n = Número
print(n.valor)
# 5
\end{lstlisting}
A su vez, puedes utilizar la función \lstinline|__init__(self, args)| interna para definir ciertas variables internas de una clase. Para ello considere el siguiente código:
\begin{lstlisting}
class Persona:
	def __init__(self, cadena, número):
		self.nombre = cadena
		self.edad = número
juan = Persona('Juan Doe', 22)
print(juan.nombre, juan.edad)
# Juan Doe 22
\end{lstlisting}
La utilidad de las clases es que puedes definir varios objetos gracias a estas herramientas siguiendo el mismo patrón. Asimismo, puedes definir varias funciones internas de la clase que hacen el código más sencillo, por ejemplo:
\begin{lstlisting}
class Persona:
	def __init__(self, cadena, número):
		self.nombre = cadena
		self.edad = número
	def presentarse(self):
		print('Mi nombre es', self.nombre, 'y tengo', self.edad, 'años')
juan = Persona('Juan Doe', 22)
juan.presentarse()
# Mi nombre es Juan Doe y tengo 22 años
\end{lstlisting}
Vemos que el \lstinline|self| sirve para referenciar a la variable original. Podemos borrar ciertas variables internas con la palabra \lstinline|del|:
\begin{lstlisting}
class Persona:
	def __init__(self, cadena, número):
		self.nombre = cadena
		self.edad = número
juan = Persona('Juan Doe', 22)
del juan.edad
print(juan.edad)
# AttributeError: 'Persona' object has no attribute 'edad'
# ErrorDeAtributo: Objeto 'Persona' no posee atributo 'edad'
\end{lstlisting}

\section{Uso de archivos}
Una aplicación particularmente útil de Python es para modificar y crear archivos externos a gusto. Esta sección es algo corta pero elemental, en especial para cosas como servidores, bases de datos o incluso, investigación (para estadística podríamos utilizar un documento en Python para guardar cierta información  y otro para transcribir dicha en una tabla o un gráfico).

Todos los métodos comienzan con una variable, usualmente denotada como \lstinline|f| (de \textit{file}, archivo) con la que abrimos un archivo en dicha carpeta, luego siguen distintos tipos de comandos:
\begin{center}
	\begin{longtable}{lp{8cm}}\hline
	\lstinline|x| & Crear archivo -- da error si este ya existe.\\
	\lstinline|r| & Leer archivo -- da error si este no existe.\\
	\lstinline|w| & Sobreescribir archivo -- si no existe, lo crea; todo contenido previo será eliminado.\\
	\lstinline|a| & Añadir texto a un archivo -- si no existe, lo crea; todo contenido previo se conserva y Python escribe al final del escrito.\\ \hline
	\end{longtable}
\end{center}
Una aplicación básica es la siguiente:
\begin{lstlisting}
f = open('Texto.txt', 'w')
f.write('Hola') # Se escribe en el archivo de texto
f.close() # Tras usarse el archivo debe cerrarse
\end{lstlisting}
Cabe destacar que se puede simplificar un poco la notación por medio del siguiente código que hace exactamente lo mismo:
\begin{lstlisting}
with open('Texto.txt', 'w') as f:
	f.write('Hola')
\end{lstlisting}
Para leer el texto, utilizamos \lstinline|.read()|.

\section{Ejemplos}
\subsection*{Teoría de números}
Uno de los usos más prácticos de la computación en general para los matemáticos va en el campo de la teoría de números, pues propiedades como el ser \textit{primo} son difíciles de realizar a mano, con dicha introducción el lector ya puede prevenir que la parte uno de la tarea es crear una función que regrese de forma binaria (verdadero o falso) si un entero es primo, para ello puede valerse de la propiedad que asegura eficiencia que dice que un $p$ es primo si no es divisible por ningún natural mayor que 1 y menor o igual a $\sqrt{p}$.

La parte dos es el filtro total: Crear una función secundaria que dado un límite $n$ otorgue todos los primos en una lista hasta tal número (por ejemplo $f(10)=(2,3,5,7)$).

{\bfseries Pista:} Se recomienda importar una función para la raíz, como \lstinline|sqrt()| del módulo \lstinline|math|. Además se requerirá de un bucle que chequee todos los números, pero no necesita partir del 1 sino del 2 (pues es obvio que cualquier entero será divisible por 1).\\
\textsc{Respuesta:}
\begin{lstlisting}[numbers=left]
from math import sqrt # importa raíz cuadrada

def esPrimo(p):
	if p <= 1: # filtro inmediato
		return False
	for i in range(2, int(sqrt(p)) + 1): # chequear desde el 2 hasta la -parte entera- de la raíz, el '+1', pues range llega hasta el anterior
		if p % i == 0: # ¿es 'p' divisible por 'i'?
			return False
	return True # al regresar un valor se sale del bucle, si no salió, ¡entonces es primo!

def primosHasta(n):
	lista = []
	if n <= 1: # filtro inmediato
		return lista
	for i in range(2, n + 1):
		if esPrimo(i):
			lista.append(i) # si es primo, inclúyelo a la lista
	return lista

limit = int(input('Lista de primos hasta el '))
print(primosHasta(limit))
\end{lstlisting}

\subsection*{Base de datos (básica)}
Ahora se le pide al lector hacer una base de datos sencilla, capaz de crear cuentas y reconocer si una conectarse a alguna. \textbf{Pista:} Para ello necesitaremos de usar un archivo externo dónde guardar nuestra información, otro detalle es poner ojo que ocurre si no existiése dicho archivo --advertir posibles errores por Python al no encontrarle--.\\
\textsc{Respuesta:}
\begin{lstlisting}[numbers=left]
def crearCuenta():
	print('Para crear un nuevo usuario, escriba su nombre de usuario y contraseña')
	usuario, contraseña, enUso = '', '', True 
	while len(usuario) <= 4 or not(usuario.isalnum()) or enUso: # mientras el usuario tenga pocos caracteres, no sean alfanuméricos o este en uso, repetir
		usuario = input('Usuario: ')
		try: # intentar, pues si el archivo no existe mandaría error
			with open('usersdata.lib', 'r') as f:
				enUso = True if (f'user: {usuario}' in f.read()) else False # ¿está el usuario ya en uso?
			if enUso:
				print('Este usuario ya existe')
				continue # saltar el resto e intentar de nuevo
		except:
			enUso = False # si no existe, evidentemente no está en uso
		if len(usuario) <= 4:
			print('Debe tener más de cuatro caracteres')
		if not usuario.isalnum():
			print('Los caracteres deben ser alfanuméricos')
	while len(contraseña) < 6 or not(contraseña.isalnum()):
		contraseña = input('Contraseña: ')
		if len(contraseña) < 6:
			print('Debe tener más de seis caracteres')
		if not contraseña.isalnum():
			print('Los caracteres deben ser alfanuméricos')
	with open('usersdata.lib', 'a') as f:
		f.write(f'user: {usuario}, pass: {contraseña}\n') # añadir nuevo usuario con su correspondiente contraseña

def abrirCuenta():
	try: # intentar, podría no haber archivo
		with open('usersdata.lib', 'r') as f:
			contenido = f.read()
			print('Para acceder a una cuenta, escriba su nombre y su usuario')
			while True:
				usuario, contraseña = input('Usuario: '), input('Contraseña: ')
				if not(f'user: {usuario}' in contenido):
					print('¡El usuario no existe!')
					continue
				if not(f'user: {usuario}, pass: {contraseña}' in contenido):
					print('Contraseña incorrecta')
				else:
					print('Bienvenido,', usuario)
					break 
	except:
		print('No hay usuarios')

print('Bienvenido a un programa simple de usuarios, para crear un nuevo usuario escriba "sign in", para acceder a uno escriba "login"')
comando = ''
while not(comando == 'sign in' or comando == 'login'):
	comando = input('')
	if comando == 'sign in':
		crearCuenta()
	elif comando == 'login':
		abrirCuenta()
	else:
		print('Error: Comando no reconocido, intente de nuevo')
\end{lstlisting}

\chapter{Métodos de listas y graficación}
Tecnicamente, llegado al capítulo 3, el curso de Python a ``terminado''. Sin embargo, me niego rotundamente a dejarlo sin repasar lo que creo es uno de los paquetes más importantes de Python: Numpy y Matplotlib. El problema de ambos es que no vienen incluidos en Python por defecto, es decir, debemos descargarlos e instalarlos, y para ello hay dos formas:

La primera es ir a la terminal o símbolo del sistema, buscar el directorio donde se encuentra el archivo de \texttt{python.exe} y ahí escriba
\begin{lstlisting}
pip install paquete-deseado
\end{lstlisting}
esto le dice al programa que instale y descargue dicho módulo. En PyCharm es aún más sencillo, pues debe ir a \texttt{File > Settings > Project Interpreter > +} y escribir el módulo que se desea descargar, finalmente, presione \texttt{Install package}. Esto producirá el mismo efecto en sincronía que descarga e instala otros paquetes necesarios. En este capítulo requeriremos dos paquetes: Numpy y Matplotlib, puede descargar el último pues requiere del primero y, por tanto, se descargan simultáneamente.

\section{Numpy}
Quiero que considere el siguiente ejemplo: Supongamos que tenemos una lista de valores y queremos sumarle una cantidad cualquiera, un error que podríamos cometer es el de escribir
\begin{lstlisting}
lista = [1, 2, 3, 4, 5]
lista + 1
# TypeError: can only concatenate list (not "int") to list
\end{lstlisting}
Por supuesto, Python interpreta que queremos unir dos listas, pero que 1 no es una lista sino un entero, luego da error, pero realmente queríamos sumarle 1 a cada valor individual. En el proceso podemos llegar a escribir un largo y frustrante bucle; ¿y si quisieramos aplicar más operaciones? ¡Sería el colmo! Estas incógnitas no son externas a un matemático o un físico al, por ejemplo, trabajar con vectores; en este contexto se aplica Numpy. Primero hemos de importar el módulo
\begin{lstlisting}
import numpy
\end{lstlisting}
y luego convertimos nuestra lista en un \textit{array de numpy} como sigue
\begin{lstlisting}
lista = [1, 2, 3, 4, 5]
lista = numpy.array(lista)
\end{lstlisting}
Finalmente imprimimos la suma con la sintax anterior:
\begin{lstlisting}
print(lista + 1)
# [2 3 4 5 6]
\end{lstlisting}
\textbf{Nota:} Observe como al imprimir arrays de Numpy, el programa no utiliza comas.

Todas las operaciones comunes y corrientes entre números se aplican a un array de Numpy.

\end{document}